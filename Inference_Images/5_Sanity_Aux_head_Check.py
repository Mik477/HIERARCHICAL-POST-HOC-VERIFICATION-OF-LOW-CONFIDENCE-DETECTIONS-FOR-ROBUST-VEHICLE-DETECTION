import torch
from pathlib import Path

# Point this to the checkpoint file you want to inspect.
# It should be the one generated by the train_aux_heads.py script.
CHECKPOINT_PATH = Path("C:/Users/mika3/Desktop/MIO_TCD_YOLO_Hierarchical/POST_Bulgaria/models/hierarchical_heads.pt")

def inspect_aux_heads_checkpoint(path: Path):
    """
    Loads an auxiliary heads checkpoint and prints the names and shapes
    of all layers in its state_dict.
    """
    if not path.exists():
        print(f"ERROR: Checkpoint file not found at: {path.resolve()}")
        return

    print(f"--- Inspecting Checkpoint: {path.name} ---")
    
    try:
        # Load the checkpoint dictionary onto the CPU to avoid GPU memory issues
        checkpoint = torch.load(path, map_location=torch.device('cpu'))
        
        # The weights are stored under the 'model_state_dict' key
        if 'model_state_dict' not in checkpoint:
            print("ERROR: The key 'model_state_dict' was not found in the checkpoint.")
            print("         This may not be a valid checkpoint from train_aux_heads.py.")
            return
            
        state_dict = checkpoint['model_state_dict']
        
        print("\n[ Layers found in model_state_dict ]\n")
        max_key_len = max(len(key) for key in state_dict.keys())
        
        for key, value in state_dict.items():
            # value is the tensor of weights/biases
            shape = list(value.shape)
            print(f"{key:<{max_key_len}} | Shape: {shape}")

        # Automated Architecture Inference
        print("\n\n--- Automated Architecture Inference ---")
        try:
            l1_head_weight_shape = state_dict['l1_head.weight'].shape
            l1_neck_dim_inferred = l1_head_weight_shape[1] # [out_features, in_features]
            print(f"Inferred l1_neck_dim: {l1_neck_dim_inferred}")

            l2_head_weight_shape = state_dict['l2_head.weight'].shape
            l2_neck_dim_inferred = l2_head_weight_shape[1]
            num_l2_classes_inferred = l2_head_weight_shape[0]
            print(f"Inferred l2_neck_dim: {l2_neck_dim_inferred}")
            print(f"Inferred num_l2_classes: {num_l2_classes_inferred}")

            trunk_output_shape = state_dict['l1_neck.0.weight'].shape # Get input dim of first layer in neck
            trunk_output_dim = trunk_output_shape[1]
            print(f"Inferred trunk_output_dim: {trunk_output_dim}")

        except KeyError as e:
            print(f"Could not automatically infer architecture. Missing key: {e}")

    except Exception as e:
        print(f"An unexpected error occurred while loading the checkpoint: {e}")

if __name__ == '__main__':
    inspect_aux_heads_checkpoint(CHECKPOINT_PATH)